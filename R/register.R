.pkgenv <- new.env(parent = emptyenv())

.pkgenv$resources <- list()
.pkgenv$indicators <- list()
.pkgenv$avail_resources <- list()

.onLoad <- function(libname, pkgname) {
  .pkgenv$outdir <- tempfile()
  dir.create(.pkgenv$outdir, showWarnings = FALSE)
  .pkgenv$verbose <- TRUE
  .pkgenv$aria_bin <- NULL
  .pkgenv$testing <- FALSE
  invisible()
}


#' Options for mapme.biodiversity
#'
#' Sets default options for mapme.biodiversity to control the behavior of
#' downstream functions.
#' Mainly, the output path as well as the temporal directory for intermediate
#' files can be set. Additionally, the verbosity can be set. The testing options
#' should not be set by users, as it controls the behavior of the package during
#' automated test pipelines. Might be extended by other options in the future.
#'
#' @param ... ignored
#' @param outdir A length one character indicating the output path.
#' @param aria_bin A character vector to an aria2c executable for parallel
#'  downloads.
#' @param verbose A logical, indicating if informative messages should be printed.
#' @param testing A logical. Not to be set by users. Controls the behavior
#'   during automated test pipelines.
#' @return A list of options if no arguments are specified. Otherwise sets
#'   matching arguments to new values in the package's internal environment.
#' @export
#'
#' @examples
#' library(mapme.biodiversity)
#' mapme_options()
mapme_options <- function(..., outdir, verbose, aria_bin, testing) {
  if (!missing(outdir)) {
    stopifnot(is.character(outdir) && length(outdir) == 1)
    if (!dir.exists(outdir)) {
      stop("outdir must point to an existing directory")
    }
    .pkgenv$outdir <- outdir
  }

  if (!missing(verbose)) {
    stopifnot(is.logical(verbose))
    .pkgenv$verbose <- verbose
  }

  if (!missing(aria_bin)) {
    .pkgenv$aria_bin <- .check_aria2(aria_bin)
  }

  if (!missing(testing)) {
    stopifnot(is.logical(testing))
    .pkgenv$testing <- testing
  }

  if (nargs() == 0) {
    return(list(
      outdir = .pkgenv$outdir,
      verbose = .pkgenv$verbose,
      aria_bin = .pkgenv$aria_bin,
      testing = .pkgenv$testing
    ))
  }
}

.check_aria2 <- function(aria_bin) {
  aria_output <- try(system2(aria_bin, args = "--version", stdout = TRUE, stderr = FALSE), silent = TRUE)
  if (inherits(aria_output, "try-error") | !grepl("aria2 version", aria_output[1])) {
    warning(paste(
      "Argument 'aria_bin' does not point to a executable aria2 installation.",
      "The package will use R internal download utility."
    ))
    aria_bin <- NULL
  }
  return(aria_bin)
}

#' Register a new resource to the mapme.biodiversity
#'
#' Registers a custom resource function to access data or functionality
#' otherwise not native to \code{mapme.biodiversity} to be used with
#' \code{get_resources()}. Custom resources will also be registered in the list
#' generated by \code{available_resources()}.
#'
#' Note that registering your own resource function will only have effect for
#' the current R session. If you return to your analysis in a new session, you
#' will have to re-register your custom resource.
#'
#' @param name A character vector indicating the name of the resource.
#' @param type A character vector indicating the type of the resource. Either
#'   'vector' or 'raster'.
#' @param source Optional, preferably a URL where the data is found.
#'
#' @return Nothing. Registers the function in the package environment.
#' @export
#'
#' @examples
#' \dontrun{
#' register_resource(
#'   name = "gfw_treecover",
#'   type = "raster",
#'   source = "https://data.globalforestwatch.org/documents/tree-cover-2000/explore"
#' )
#' }
register_resource <- function(name = NULL, type = NULL, source = NULL) {
  if (any(is.null(name), is.null(type), is.null(source))) {
    stop("neither name, type, or source can be NULL")
  }

  if (!inherits(name, "character") || length(name) > 1 || nchar(name) == 0) {
    stop("name needs to be a single charachter string")
  }

  if (name %in% names(.pkgenv$resources)) {
    warning(paste("resource with name", name, "already registered"))
  }

  if (!type %in% c("vector", "raster")) {
    stop("type needs to be one of 'vector' or 'raster'")
  }

  if ((!inherits(source, "character") || length(source) > 1) & !is.null(source)) {
    stop("source needs to be a single charachter string")
  }

  resource <- list(list(type = type, source = source))
  names(resource) <- name
  .pkgenv$resources <- append(.pkgenv$resources, resource)
}



#' Register a new indicator to mapme.biodiversity
#'
#' Registers a custom indicator function to access indicators not native to
#' \code{mapme.biodiversity} to be used with \code{calc_indicators()}. Custom
#' indicators will also be registered in the list generated by
#' \code{available_indicators()}.
#'
#' Note that registering your own indicator function will only have effect for
#' the current R session. If you return to your analysis in a new session, you
#' will have to re-register your custom indicator.
#'
#' @param name A character vector indicating the name of the indicator.
#' @param resources A list with named objects indicating the resources
#'   that need to be available to calculate the indicator. The names correspond
#'   to registered resources and a single character value indicates the
#'   type of that resources
#'
#' @return Nothing. Registers the function in the package environment.
#' @export
#'
#' @examples
#' \dontrun{
#' register_indicator(
#'   name = "treecover_area",
#'   resources = list(
#'     gfw_treecover = "raster",
#'     gfw_lossyear = "raster"
#'   )
#' )
#' }
register_indicator <- function(name = NULL, resources = NULL) {
  if (any(is.null(name), is.null(resources))) {
    stop("neither name nor resources can be NULL")
  }
  if (!inherits(name, "character") || length(name) > 1 || nchar(name) == 0) {
    stop("name needs to be a single charachter string")
  }
  if (name %in% names(.pkgenv$indicators)) {
    warning(paste("indicator with name", name, "already registered"))
  }

  if (!inherits(resources, "list")) {
    stop(paste(
      "resources needs to be a list indicating the required resources",
      "and their types"
    ))
  }
  check_resources <- sapply(resources, function(x) x %in% c("vector", "raster"))

  if (any(!check_resources)) {
    wrong_types <- names(check_resources)[!check_resources]
    stop(paste(
      "the following resources have an unknown type specified: ",
      paste(wrong_types, sep = "", collapse = ", ")
    ))
  }

  indicator <- list(list(resources = resources))
  names(indicator) <- name
  .pkgenv$indicators <- append(.pkgenv$indicators, indicator)
}



#' Backlog function for available resources
#'
#' Returns a list of resource names and parametrization options for the
#' specified resources. If no resource names are provided, it lists all
#' available resources, including custom registered ones.
#' Use it to learn about possible additional arguments that can be specified
#' when requesting a resource.
#'
#' @param resources If \code{NULL} returns a list of all resources (default).
#'   Otherwise only the ones specified.
#'
#' @return A list object.
#' @export
#' @keywords resource
#' @include register.R
#' @examples
#' names(available_resources())
available_resources <- function(resources = NULL) {
  all_resources <- .pkgenv$resources

  if (is.null(resources)) {
    return(all_resources[order(names(all_resources))])
  } else {
    if (any(!resources %in% names(all_resources))) {
      not_avail <- which(!resources %in% names(all_resources))
      not_avail <- resources[not_avail]
      msg <- sprintf(
        "The following resources are not available:\n%s",
        paste(not_avail, collpase = ", ")
      )
      stop(msg)
    }
    all_resources[resources]
  }
}



#' Backlog function for available indicators
#'
#' Returns a list of indicator names and parametrization options for the
#' specified indicators. If no resource names are provided, it lists all
#' available indicators, including custom registered ones.
#' Use it to learn about possible additional arguments that can be specified
#' when requesting an indicator.
#'
#' @param indicators If \code{NULL} returns a list of all registered indicators
#' (default). Otherwise only the ones specified.
#'
#' @return A list object.
#' @export
#' @keywords indicator
#' @include register.R
#' @examples
#' names(available_indicators())
available_indicators <- function(indicators = NULL) {
  all_indicators <- .pkgenv$indicators

  if (is.null(indicators)) {
    return(all_indicators[order(names(all_indicators))])
  } else {
    if (any(!indicators %in% names(all_indicators))) {
      not_avail <- which(!indicators %in% names(all_indicators))
      not_avail <- indicators[not_avail]
      msg <- sprintf(
        "The following indicators are not available:\n%s",
        paste(not_avail, collpase = ", ")
      )
      stop(msg)
    }
    all_indicators[indicators]
  }
}


.add_resource <- function(resource) {
  stopifnot(inherits(resource, "list"))
  stopifnot(!is.null(names(resource)))
  if (length(.pkgenv$avail_resources) == 0) {
    .pkgenv$avail_resources <- resource
  } else {
    name <- names(resource)
    .pkgenv$avail_resources[name] <- resource
  }
}

.avail_resources <- function(name) {
  return(.pkgenv$avail_resources)
}

.clear_resources <- function() {
  .pkgenv$avail_resources <- list()
}
